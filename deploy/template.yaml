AWSTemplateFormatVersion: "2010-09-09"

Description: >-
  This creates the necessary components to deploy IPV Core Front onto ECS
  Fargate within an existing VPC and private subnets (provided as parameters).
  Core Front can be invoked via the public API Gateway on the url in the
  CoreFrontUrl output.

  The ingress route in summary is: API Gateway -> VPC link -> private ALB ->
  Core Front ECS Service

  Core Front egress to Core Back's API Gateway is via a NAT Gateway, not created
  here, which should have a route in the provided private subnets' route table.

Parameters:
  Environment:
    Description: The name of the environment to deploy to.
    Type: String
    AllowedPattern: ((production)|(integration)|(staging)|(build)|(dev.*))
  ImageTag:
    Description: The tag of core-front image to deploy in the task definition.
    Type: String
  SubnetIds:
    Description: >-
      A comma separated list of subnet ids to create the ECS service and Load Balancer
      within. Each subnet must have a route to a public NAT gateway since
      the ECS Service are provisioned without a public IP address.
      Example "sg-123, sg-567, sg-8910"
    Type: List<String>
  VpcId:
    Description: >-
      The VPC id in which to create the components.
      Example "vpc-123"
    Type: String

Conditions:
  IsNotDevelopment: !Or
    - !Equals [!Ref Environment, build]
    - !Equals [!Ref Environment, staging]
    - !Equals [!Ref Environment, integration]
    - !Equals [!Ref Environment, production]

# The AWS Account Id is used in the following mapping section because we have
# multiple developer environments and it is undesirable to have to keep this
# mapping up to date with each developer environment.
Mappings:
  EcsConfiguration:
    "130355686670": # Development
      desiredTaskCount: 1
    "457601271792": # Build
      desiredTaskCount: 1
    "335257547869": # Staging
      desiredTaskCount: 1
    "991138514218": # Integration
      desiredTaskCount: 1
    "075701497069": # Production
      desiredTaskCount: 2

Resources:
  # Security Groups for the ECS service and load balancer
  LoadBalancerSG:
    Type: "AWS::EC2::SecurityGroup"
    Properties:
      GroupDescription: >-
        Core Front LoadBalancer Security Group
      SecurityGroupIngress:
        - CidrIp: 0.0.0.0/0
          Description: Allow from anyone on port 80
          FromPort: 80
          IpProtocol: tcp
          ToPort: 80
      VpcId: !Ref VpcId

  LoadBalancerSGEgressToECSSecurityGroup:
    Type: "AWS::EC2::SecurityGroupEgress"
    Properties:
      GroupId: !GetAtt LoadBalancerSG.GroupId
      IpProtocol: tcp
      Description: >-
        Egress between the Core Front load balancer and
        the core front ECS security group
      DestinationSecurityGroupId: !GetAtt ECSSecurityGroup.GroupId
      FromPort: 8080
      ToPort: 8080

  ECSSecurityGroup:
    Type: "AWS::EC2::SecurityGroup"
    Properties:
      GroupDescription: >-
        Core Front ECS Security Group permitting outbound
        to anywhere.
      SecurityGroupEgress:
        - CidrIp: 0.0.0.0/0
          Description: Allow all outbound traffic by default
          IpProtocol: "-1"
      VpcId: !Ref VpcId

  ECSSecurityGroupIngressFromLoadBalancer:
    Type: "AWS::EC2::SecurityGroupIngress"
    Properties:
      IpProtocol: tcp
      Description: >-
        Core Front ECS permits inbound from the Core Front
        load balancer.
      FromPort: 8080
      ToPort: 8080
      GroupId: !GetAtt ECSSecurityGroup.GroupId
      SourceSecurityGroupId: !GetAtt LoadBalancerSG.GroupId

  AccessLogsBucket:
    Type: AWS::S3::Bucket
    #checkov:skip=CKV_AWS_18: This is the bucket where our access logs go and AWS advise not sending a bucket's access logs to itself.
    Properties:
      BucketName: !Sub ipv-core-${Environment}-access-logs
      AccessControl: LogDeliveryWrite
      VersioningConfiguration:
        Status: "Enabled"
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256

  CoreFrontAccessLogsBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref AccessLogsBucket
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              AWS:
                - arn:aws:iam::652711504416:root
            Action:
              - s3:PutObject
            Resource:
              - !Sub arn:aws:s3:::${AccessLogsBucket}/core-front-${Environment}/AWSLogs/${AWS::AccountId}/*
          - Effect: Allow
            Principal:
              Service: logging.s3.amazonaws.com
            Action: s3:PutObject
            Resource: !Sub "arn:aws:s3:::${AccessLogsBucket}/*"
            Condition:
              StringEquals:
                "aws:SourceAccount": !Sub "${AWS::AccountId}"

  # Private Application Load Balancer
  LoadBalancer:
    Type: "AWS::ElasticLoadBalancingV2::LoadBalancer"
    Properties:
      Scheme: internal
      SecurityGroups:
        - !GetAtt LoadBalancerSG.GroupId
      Subnets: !Ref SubnetIds
      Type: application
      #checkov:skip=CKV_AWS_91:ALB access logging is disabled in developer environments to make them easier to manage.
      LoadBalancerAttributes:
        - Key: routing.http.drop_invalid_header_fields.enabled
          Value: true
        - !If
          - IsNotDevelopment
          - Key: access_logs.s3.enabled
            Value: true
          - !Ref AWS::NoValue
        - !If
          - IsNotDevelopment
          - Key: access_logs.s3.bucket
            Value: !Ref AccessLogsBucket
          - !Ref AWS::NoValue
        - !If
          - IsNotDevelopment
          - Key: access_logs.s3.prefix
            Value: !Sub core-front-${Environment}
          - !Ref AWS::NoValue
    DependsOn: CoreFrontAccessLogsBucketPolicy

  LoadBalancerListenerTargetGroupECS:
    Type: "AWS::ElasticLoadBalancingV2::TargetGroup"
    Properties:
      HealthCheckEnabled: TRUE
      HealthCheckProtocol: HTTP
      HealthCheckPath: /healthcheck
      Matcher:
        HttpCode: 200
      Port: 80
      Protocol: HTTP
      TargetType: ip
      VpcId: !Ref VpcId
      TargetGroupAttributes:
        - Key: deregistration_delay.timeout_seconds
          Value: 60

  LoadBalancerListener:
    Type: "AWS::ElasticLoadBalancingV2::Listener"
    Properties:
      # checkov:skip=CKV_AWS_2:Certificate generation must be resolved before the listener can use HTTPS.
      # checkov:skip=CKV_AWS_103:The load balancer cannot use TLS v1.2 until HTTPS is enabled
      DefaultActions:
        - TargetGroupArn: !Ref LoadBalancerListenerTargetGroupECS
          Type: forward
      LoadBalancerArn: !Ref LoadBalancer
      Port: 80
      Protocol: HTTP

  # ECS cluster, service and task definition
  CoreFrontEcsCluster:
    Type: "AWS::ECS::Cluster"
    Properties:
      ClusterSettings:
        - Name: containerInsights
          Value: enabled

  CoreFrontEcsService:
    Type: "AWS::ECS::Service"
    Properties:
      Cluster: !Ref CoreFrontEcsCluster
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 50
        DeploymentCircuitBreaker:
          Enable: true
          Rollback: true
      DeploymentController:
        Type: ECS
      DesiredCount: !FindInMap
        - EcsConfiguration
        - !Ref AWS::AccountId
        - desiredTaskCount
      EnableECSManagedTags: false
      HealthCheckGracePeriodSeconds: 60
      LaunchType: FARGATE
      LoadBalancers:
        - ContainerName: app
          ContainerPort: 8080
          TargetGroupArn: !Ref LoadBalancerListenerTargetGroupECS
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: DISABLED
          SecurityGroups:
            - !GetAtt ECSSecurityGroup.GroupId
          Subnets: !Ref SubnetIds
      TaskDefinition: !Ref ECSServiceTaskDefinition
    DependsOn:
      - LoadBalancerListener

  ECSAccessLogsGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/ecs/${AWS::StackName}-CoreFront-ECS
      RetentionInDays: 14
      KmsKeyId: !GetAtt LoggingKmsKey.Arn

  ECSAccessLogsGroupSubscriptionFilter:
    Type: AWS::Logs::SubscriptionFilter
    Properties:
      DestinationArn: "arn:aws:logs:eu-west-2:885513274347:destination:csls_cw_logs_destination_prod"
      FilterPattern: ""
      LogGroupName: !Ref ECSAccessLogsGroup

  ECSServiceTaskDefinition:
    Type: "AWS::ECS::TaskDefinition"
    Properties:
      ContainerDefinitions:
        - Essential: true
          Image: !If [
              IsNotDevelopment,
              !Sub "457601271792.dkr.ecr.${AWS::Region}.amazonaws.com/core-front-build:${ImageTag}",
              !Sub "${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/core-front-development:${ImageTag}",
            ] # Uses build account and ECR when not in development.
          Name: app
          Environment:
            - Name: API_BASE_URL
              Value: !Sub
                - "https://${APIGatewayId}.execute-api.eu-west-2.amazonaws.com/${Environment}"
                - APIGatewayId:
                    Fn::ImportValue: !Sub ipv-core-back-${Environment}-IPVCorePrivateAPIGatewayID
                  Environment: !Ref Environment
            - Name: EXTERNAL_WEBSITE_HOST
              Value: !GetAtt ApiGwHttpEndpoint.ApiEndpoint
          PortMappings:
            - ContainerPort: 8080
              Protocol: tcp
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref ECSAccessLogsGroup
              awslogs-region: !Sub ${AWS::Region}
              awslogs-stream-prefix: !Sub core-front-${Environment}
      Cpu: "512"
      ExecutionRoleArn: !GetAtt ECSTaskExecutionRole.Arn
      Memory: "1024"
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      TaskRoleArn: !GetAtt ECSTaskRole.Arn

  ECSTaskExecutionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: "sts:AssumeRole"
            Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
        Version: 2012-10-17
      Policies:
        - PolicyName: PullCoreFrontImage
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "ecr:BatchGetImage"
                  - "ecr:GetDownloadUrlForLayer"
                  - "ecr:GetAuthorizationToken"
                Resource:
                  - "*"
              - Effect: Allow
                Action:
                  - "logs:CreateLogStream"
                  - "logs:PutLogEvents"
                Resource:
                  - !GetAtt "ECSAccessLogsGroup.Arn"
                  - !Sub "${ECSAccessLogsGroup.Arn}:*"
        - PolicyName: CoreFrontDynamoDBSessionAccess
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "dynamodb:BatchGetItem"
                  - "dynamodb:DescribeTable"
                  - "dynamodb:GetItem"
                  - "dynamodb:Query"
                  - "dynamodb:Scan"
                  - "dynamodb:BatchWriteItem"
                  - "dynamodb:DeleteItem"
                  - "dynamodb:UpdateItem"
                  - "dynamodb:PutItem"
                Resource:
                  - !GetAtt CoreFrontSessionsTable.Arn

  ECSTaskRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: "sts:AssumeRole"
            Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
        Version: 2012-10-17

  # Create the VPC Link to join the API Gateway to the
  # private Load Balancer in front of Core Front ECS
  # Service.
  VpcLink:
    Type: "AWS::ApiGatewayV2::VpcLink"
    Properties:
      Name: ApiGwVpcLinkToLoadBalancer
      SubnetIds: !Ref SubnetIds
      SecurityGroupIds: []

  ApiGwHttpEndpoint:
    Type: "AWS::ApiGatewayV2::Api"
    Properties:
      Name: !Sub ipv-core-front-${Environment}
      ProtocolType: HTTP

  ApiGwHttpEndpointIntegration:
    Type: "AWS::ApiGatewayV2::Integration"
    Properties:
      ApiId: !Ref ApiGwHttpEndpoint
      IntegrationType: HTTP_PROXY
      ConnectionId: !Ref VpcLink
      ConnectionType: VPC_LINK
      IntegrationMethod: ANY
      IntegrationUri: !Ref LoadBalancerListener
      PayloadFormatVersion: "1.0"

  APIGWRoute:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref ApiGwHttpEndpoint
      RouteKey: "ANY /{proxy+}"
      Target: !Join
        - /
        - - integrations
          - !Ref ApiGwHttpEndpointIntegration

  APIStageDefault:
    Type: "AWS::ApiGatewayV2::Stage"
    Properties:
      ApiId: !Ref ApiGwHttpEndpoint
      StageName: $default
      AutoDeploy: true
      AccessLogSettings:
        DestinationArn: !GetAtt APIGWAccessLogsGroup.Arn
        Format: >-
          {
          "requestId":"$context.requestId",
          "ip": "$context.identity.sourceIp",
          "requestTime":"$context.requestTime",
          "httpMethod":"$context.httpMethod",
          "path": "$context.path",
          "routeKey":"$context.routeKey",
          "status":"$context.status",
          "protocol":"$context.protocol",
          "responseLength":"$context.responseLength"
          }

  APIGWAccessLogsGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/apigateway/${AWS::StackName}-CoreFront-API-GW-AccessLogs
      RetentionInDays: 14
      KmsKeyId: !GetAtt LoggingKmsKey.Arn

  APIGWAccessLogsGroupSubscriptionFilter:
    Type: AWS::Logs::SubscriptionFilter
    Properties:
      DestinationArn: "arn:aws:logs:eu-west-2:885513274347:destination:csls_cw_logs_destination_prod"
      FilterPattern: ""
      LogGroupName: !Ref APIGWAccessLogsGroup

  LoggingKmsKey:
    Type: AWS::KMS::Key
    Properties:
      EnableKeyRotation: true
      KeyPolicy:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              AWS: !Sub "arn:aws:iam::${AWS::AccountId}:root"
            Action:
              - kms:*
            Resource: "*"
          - Effect: Allow
            Principal:
              Service: !Sub "logs.${AWS::Region}.amazonaws.com"
            Action:
              - "kms:Encrypt*"
              - "kms:Decrypt*"
              - "kms:ReEncrypt*"
              - "kms:GenerateDataKey*"
              - "kms:Describe*"
            Resource: "*"
            Condition:
              ArnLike:
                "kms:EncryptionContext:aws:logs:arn": !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*"

  CoreFrontSessionsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      # checkov:skip=CKV_AWS_28: Point in time recovery is not necessary for this table.
      TableName: !Sub "core-front-sessions-${Environment}"
      BillingMode: "PAY_PER_REQUEST"
      AttributeDefinitions:
        - AttributeName: "id"
          AttributeType: "S"
      KeySchema:
        - AttributeName: "id"
          KeyType: "HASH"
      TimeToLiveSpecification:
        AttributeName: "expires"
        Enabled: true
      SSESpecification:
        # checkov:skip=CKV_AWS_119: Implement Customer Managed Keys in PYIC-1391
        SSEEnabled: true
        SSEType: KMS

Outputs:
  CoreFrontUrl:
    Description: >-
      The API Gateway URL which Core Front can be invoked on.
    Value: !GetAtt ApiGwHttpEndpoint.ApiEndpoint
  IPVCoreFrontGatewayID:
    Description: Core Front API Gateway ID
    Export:
      Name: !Sub "${AWS::StackName}-IPVCoreFrontGatewayID"
    Value: !Ref ApiGwHttpEndpoint
